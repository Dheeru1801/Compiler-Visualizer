Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> external_declarations
Rule 2     external_declarations -> external_declarations external_declaration
Rule 3     external_declarations -> external_declaration
Rule 4     external_declaration -> type ID LPAREN params RPAREN block
Rule 5     external_declaration -> type ID LPAREN RPAREN block
Rule 6     external_declaration -> statement
Rule 7     params -> params COMMA param
Rule 8     params -> param
Rule 9     params -> <empty>
Rule 10    param -> type ID
Rule 11    param -> type ID LBRACKET RBRACKET
Rule 12    param -> type ID LBRACKET NUMBER RBRACKET
Rule 13    block -> LBRACE statements RBRACE
Rule 14    statements -> statements statement
Rule 15    statements -> statement
Rule 16    statements -> empty
Rule 17    statement -> type ID ASSIGN expr SEMICOLON
Rule 18    statement -> type ID SEMICOLON
Rule 19    statement -> ID ASSIGN expr SEMICOLON
Rule 20    statement -> block
Rule 21    statement -> IF LPAREN expr RPAREN statement
Rule 22    statement -> IF LPAREN expr RPAREN statement ELSE statement
Rule 23    statement -> WHILE LPAREN expr RPAREN statement
Rule 24    statement -> RETURN expr SEMICOLON
Rule 25    statement -> expr SEMICOLON
Rule 26    statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
Rule 27    for_init -> type ID ASSIGN expr
Rule 28    for_init -> ID ASSIGN expr
Rule 29    for_init -> empty
Rule 30    for_update -> ID INCREMENT
Rule 31    for_update -> ID DECREMENT
Rule 32    for_update -> ID ASSIGN expr
Rule 33    for_update -> empty
Rule 34    type -> INT
Rule 35    type -> FLOAT
Rule 36    type -> CHAR
Rule 37    expr -> term
Rule 38    expr -> expr PLUS term
Rule 39    expr -> expr MINUS term
Rule 40    expr -> expr LT term
Rule 41    expr -> expr GT term
Rule 42    expr -> expr LE term
Rule 43    expr -> expr GE term
Rule 44    expr -> expr EQ term
Rule 45    expr -> expr NEQ term
Rule 46    expr -> ID INCREMENT
Rule 47    expr -> ID DECREMENT
Rule 48    term -> term MULTIPLY factor
Rule 49    term -> term DIVIDE factor
Rule 50    term -> factor
Rule 51    factor -> NUMBER
Rule 52    factor -> ID
Rule 53    factor -> LPAREN expr RPAREN
Rule 54    factor -> ID LPAREN args RPAREN
Rule 55    empty -> <empty>
Rule 56    args -> args COMMA expr
Rule 57    args -> expr
Rule 58    args -> empty

Terminals, with rules where they appear

ASSIGN               : 17 19 27 28 32
CHAR                 : 36
COMMA                : 7 56
DECREMENT            : 31 47
DIVIDE               : 49
ELSE                 : 22
EQ                   : 44
FLOAT                : 35
FOR                  : 26
GE                   : 43
GT                   : 41
ID                   : 4 5 10 11 12 17 18 19 27 28 30 31 32 46 47 52 54
IF                   : 21 22
INCREMENT            : 30 46
INT                  : 34
LBRACE               : 13
LBRACKET             : 11 12
LE                   : 42
LPAREN               : 4 5 21 22 23 26 53 54
LT                   : 40
MINUS                : 39
MULTIPLY             : 48
NEQ                  : 45
NUMBER               : 12 51
PLUS                 : 38
RBRACE               : 13
RBRACKET             : 11 12
RETURN               : 24
RPAREN               : 4 5 21 22 23 26 53 54
SEMICOLON            : 17 18 19 24 25 26 26
WHILE                : 23
error                : 

Nonterminals, with rules where they appear

args                 : 54 56
block                : 4 5 20
empty                : 16 29 33 58
expr                 : 17 19 21 22 23 24 25 26 27 28 32 38 39 40 41 42 43 44 45 53 56 57
external_declaration : 2 3
external_declarations : 1 2
factor               : 48 49 50
for_init             : 26
for_update           : 26
param                : 7 8
params               : 4 7
program              : 0
statement            : 6 14 15 21 22 22 23 26
statements           : 13 14
term                 : 37 38 39 40 41 42 43 44 45 48 49
type                 : 4 5 10 11 12 17 18 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . external_declarations
    (2) external_declarations -> . external_declarations external_declaration
    (3) external_declarations -> . external_declaration
    (4) external_declaration -> . type ID LPAREN params RPAREN block
    (5) external_declaration -> . type ID LPAREN RPAREN block
    (6) external_declaration -> . statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    program                        shift and go to state 1
    external_declarations          shift and go to state 2
    external_declaration           shift and go to state 3
    type                           shift and go to state 4
    block                          shift and go to state 7
    statement                      shift and go to state 8
    expr                           shift and go to state 12
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 1

    (0) S' -> program .



state 2

    (1) program -> external_declarations .
    (2) external_declarations -> external_declarations . external_declaration
    (4) external_declaration -> . type ID LPAREN params RPAREN block
    (5) external_declaration -> . type ID LPAREN RPAREN block
    (6) external_declaration -> . statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    $end            reduce using rule 1 (program -> external_declarations .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    external_declaration           shift and go to state 21
    type                           shift and go to state 4
    block                          shift and go to state 7
    statement                      shift and go to state 8
    expr                           shift and go to state 12
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 3

    (3) external_declarations -> external_declaration .

    INT             reduce using rule 3 (external_declarations -> external_declaration .)
    FLOAT           reduce using rule 3 (external_declarations -> external_declaration .)
    CHAR            reduce using rule 3 (external_declarations -> external_declaration .)
    ID              reduce using rule 3 (external_declarations -> external_declaration .)
    IF              reduce using rule 3 (external_declarations -> external_declaration .)
    WHILE           reduce using rule 3 (external_declarations -> external_declaration .)
    RETURN          reduce using rule 3 (external_declarations -> external_declaration .)
    FOR             reduce using rule 3 (external_declarations -> external_declaration .)
    LBRACE          reduce using rule 3 (external_declarations -> external_declaration .)
    NUMBER          reduce using rule 3 (external_declarations -> external_declaration .)
    LPAREN          reduce using rule 3 (external_declarations -> external_declaration .)
    $end            reduce using rule 3 (external_declarations -> external_declaration .)


state 4

    (4) external_declaration -> type . ID LPAREN params RPAREN block
    (5) external_declaration -> type . ID LPAREN RPAREN block
    (17) statement -> type . ID ASSIGN expr SEMICOLON
    (18) statement -> type . ID SEMICOLON

    ID              shift and go to state 22


state 5

    (19) statement -> ID . ASSIGN expr SEMICOLON
    (46) expr -> ID . INCREMENT
    (47) expr -> ID . DECREMENT
    (52) factor -> ID .
    (54) factor -> ID . LPAREN args RPAREN

    ASSIGN          shift and go to state 23
    INCREMENT       shift and go to state 24
    DECREMENT       shift and go to state 25
    MULTIPLY        reduce using rule 52 (factor -> ID .)
    DIVIDE          reduce using rule 52 (factor -> ID .)
    SEMICOLON       reduce using rule 52 (factor -> ID .)
    PLUS            reduce using rule 52 (factor -> ID .)
    MINUS           reduce using rule 52 (factor -> ID .)
    LT              reduce using rule 52 (factor -> ID .)
    GT              reduce using rule 52 (factor -> ID .)
    LE              reduce using rule 52 (factor -> ID .)
    GE              reduce using rule 52 (factor -> ID .)
    EQ              reduce using rule 52 (factor -> ID .)
    NEQ             reduce using rule 52 (factor -> ID .)
    LPAREN          shift and go to state 26


state 6

    (53) factor -> LPAREN . expr RPAREN
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 27
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 7

    (20) statement -> block .

    INT             reduce using rule 20 (statement -> block .)
    FLOAT           reduce using rule 20 (statement -> block .)
    CHAR            reduce using rule 20 (statement -> block .)
    ID              reduce using rule 20 (statement -> block .)
    IF              reduce using rule 20 (statement -> block .)
    WHILE           reduce using rule 20 (statement -> block .)
    RETURN          reduce using rule 20 (statement -> block .)
    FOR             reduce using rule 20 (statement -> block .)
    LBRACE          reduce using rule 20 (statement -> block .)
    NUMBER          reduce using rule 20 (statement -> block .)
    LPAREN          reduce using rule 20 (statement -> block .)
    $end            reduce using rule 20 (statement -> block .)
    RBRACE          reduce using rule 20 (statement -> block .)
    ELSE            reduce using rule 20 (statement -> block .)


state 8

    (6) external_declaration -> statement .

    INT             reduce using rule 6 (external_declaration -> statement .)
    FLOAT           reduce using rule 6 (external_declaration -> statement .)
    CHAR            reduce using rule 6 (external_declaration -> statement .)
    ID              reduce using rule 6 (external_declaration -> statement .)
    IF              reduce using rule 6 (external_declaration -> statement .)
    WHILE           reduce using rule 6 (external_declaration -> statement .)
    RETURN          reduce using rule 6 (external_declaration -> statement .)
    FOR             reduce using rule 6 (external_declaration -> statement .)
    LBRACE          reduce using rule 6 (external_declaration -> statement .)
    NUMBER          reduce using rule 6 (external_declaration -> statement .)
    LPAREN          reduce using rule 6 (external_declaration -> statement .)
    $end            reduce using rule 6 (external_declaration -> statement .)


state 9

    (34) type -> INT .

    ID              reduce using rule 34 (type -> INT .)


state 10

    (35) type -> FLOAT .

    ID              reduce using rule 35 (type -> FLOAT .)


state 11

    (36) type -> CHAR .

    ID              reduce using rule 36 (type -> CHAR .)


state 12

    (25) statement -> expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 29
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 13

    (21) statement -> IF . LPAREN expr RPAREN statement
    (22) statement -> IF . LPAREN expr RPAREN statement ELSE statement

    LPAREN          shift and go to state 38


state 14

    (23) statement -> WHILE . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 39


state 15

    (24) statement -> RETURN . expr SEMICOLON
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 40
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 16

    (26) statement -> FOR . LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement

    LPAREN          shift and go to state 41


state 17

    (13) block -> LBRACE . statements RBRACE
    (14) statements -> . statements statement
    (15) statements -> . statement
    (16) statements -> . empty
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (55) empty -> .
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    RBRACE          reduce using rule 55 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

  ! ID              [ reduce using rule 55 (empty -> .) ]
  ! IF              [ reduce using rule 55 (empty -> .) ]
  ! WHILE           [ reduce using rule 55 (empty -> .) ]
  ! RETURN          [ reduce using rule 55 (empty -> .) ]
  ! FOR             [ reduce using rule 55 (empty -> .) ]
  ! INT             [ reduce using rule 55 (empty -> .) ]
  ! FLOAT           [ reduce using rule 55 (empty -> .) ]
  ! CHAR            [ reduce using rule 55 (empty -> .) ]
  ! LBRACE          [ reduce using rule 55 (empty -> .) ]
  ! NUMBER          [ reduce using rule 55 (empty -> .) ]
  ! LPAREN          [ reduce using rule 55 (empty -> .) ]

    statements                     shift and go to state 42
    statement                      shift and go to state 43
    empty                          shift and go to state 44
    type                           shift and go to state 45
    expr                           shift and go to state 12
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 18

    (37) expr -> term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 37 (expr -> term .)
    PLUS            reduce using rule 37 (expr -> term .)
    MINUS           reduce using rule 37 (expr -> term .)
    LT              reduce using rule 37 (expr -> term .)
    GT              reduce using rule 37 (expr -> term .)
    LE              reduce using rule 37 (expr -> term .)
    GE              reduce using rule 37 (expr -> term .)
    EQ              reduce using rule 37 (expr -> term .)
    NEQ             reduce using rule 37 (expr -> term .)
    RPAREN          reduce using rule 37 (expr -> term .)
    COMMA           reduce using rule 37 (expr -> term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 19

    (50) term -> factor .

    MULTIPLY        reduce using rule 50 (term -> factor .)
    DIVIDE          reduce using rule 50 (term -> factor .)
    SEMICOLON       reduce using rule 50 (term -> factor .)
    PLUS            reduce using rule 50 (term -> factor .)
    MINUS           reduce using rule 50 (term -> factor .)
    LT              reduce using rule 50 (term -> factor .)
    GT              reduce using rule 50 (term -> factor .)
    LE              reduce using rule 50 (term -> factor .)
    GE              reduce using rule 50 (term -> factor .)
    EQ              reduce using rule 50 (term -> factor .)
    NEQ             reduce using rule 50 (term -> factor .)
    RPAREN          reduce using rule 50 (term -> factor .)
    COMMA           reduce using rule 50 (term -> factor .)


state 20

    (51) factor -> NUMBER .

    MULTIPLY        reduce using rule 51 (factor -> NUMBER .)
    DIVIDE          reduce using rule 51 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 51 (factor -> NUMBER .)
    PLUS            reduce using rule 51 (factor -> NUMBER .)
    MINUS           reduce using rule 51 (factor -> NUMBER .)
    LT              reduce using rule 51 (factor -> NUMBER .)
    GT              reduce using rule 51 (factor -> NUMBER .)
    LE              reduce using rule 51 (factor -> NUMBER .)
    GE              reduce using rule 51 (factor -> NUMBER .)
    EQ              reduce using rule 51 (factor -> NUMBER .)
    NEQ             reduce using rule 51 (factor -> NUMBER .)
    RPAREN          reduce using rule 51 (factor -> NUMBER .)
    COMMA           reduce using rule 51 (factor -> NUMBER .)


state 21

    (2) external_declarations -> external_declarations external_declaration .

    INT             reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    FLOAT           reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    CHAR            reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    ID              reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    IF              reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    WHILE           reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    RETURN          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    FOR             reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    LBRACE          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    NUMBER          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    LPAREN          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    $end            reduce using rule 2 (external_declarations -> external_declarations external_declaration .)


state 22

    (4) external_declaration -> type ID . LPAREN params RPAREN block
    (5) external_declaration -> type ID . LPAREN RPAREN block
    (17) statement -> type ID . ASSIGN expr SEMICOLON
    (18) statement -> type ID . SEMICOLON

    LPAREN          shift and go to state 48
    ASSIGN          shift and go to state 49
    SEMICOLON       shift and go to state 50


state 23

    (19) statement -> ID ASSIGN . expr SEMICOLON
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 51
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 24

    (46) expr -> ID INCREMENT .

    SEMICOLON       reduce using rule 46 (expr -> ID INCREMENT .)
    PLUS            reduce using rule 46 (expr -> ID INCREMENT .)
    MINUS           reduce using rule 46 (expr -> ID INCREMENT .)
    LT              reduce using rule 46 (expr -> ID INCREMENT .)
    GT              reduce using rule 46 (expr -> ID INCREMENT .)
    LE              reduce using rule 46 (expr -> ID INCREMENT .)
    GE              reduce using rule 46 (expr -> ID INCREMENT .)
    EQ              reduce using rule 46 (expr -> ID INCREMENT .)
    NEQ             reduce using rule 46 (expr -> ID INCREMENT .)
    RPAREN          reduce using rule 46 (expr -> ID INCREMENT .)
    COMMA           reduce using rule 46 (expr -> ID INCREMENT .)


state 25

    (47) expr -> ID DECREMENT .

    SEMICOLON       reduce using rule 47 (expr -> ID DECREMENT .)
    PLUS            reduce using rule 47 (expr -> ID DECREMENT .)
    MINUS           reduce using rule 47 (expr -> ID DECREMENT .)
    LT              reduce using rule 47 (expr -> ID DECREMENT .)
    GT              reduce using rule 47 (expr -> ID DECREMENT .)
    LE              reduce using rule 47 (expr -> ID DECREMENT .)
    GE              reduce using rule 47 (expr -> ID DECREMENT .)
    EQ              reduce using rule 47 (expr -> ID DECREMENT .)
    NEQ             reduce using rule 47 (expr -> ID DECREMENT .)
    RPAREN          reduce using rule 47 (expr -> ID DECREMENT .)
    COMMA           reduce using rule 47 (expr -> ID DECREMENT .)


state 26

    (54) factor -> ID LPAREN . args RPAREN
    (56) args -> . args COMMA expr
    (57) args -> . expr
    (58) args -> . empty
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (55) empty -> .
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    RPAREN          reduce using rule 55 (empty -> .)
    COMMA           reduce using rule 55 (empty -> .)
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    args                           shift and go to state 52
    expr                           shift and go to state 53
    empty                          shift and go to state 54
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 27

    (53) factor -> LPAREN expr . RPAREN
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          shift and go to state 55
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 28

    (46) expr -> ID . INCREMENT
    (47) expr -> ID . DECREMENT
    (52) factor -> ID .
    (54) factor -> ID . LPAREN args RPAREN

    INCREMENT       shift and go to state 24
    DECREMENT       shift and go to state 25
    MULTIPLY        reduce using rule 52 (factor -> ID .)
    DIVIDE          reduce using rule 52 (factor -> ID .)
    RPAREN          reduce using rule 52 (factor -> ID .)
    PLUS            reduce using rule 52 (factor -> ID .)
    MINUS           reduce using rule 52 (factor -> ID .)
    LT              reduce using rule 52 (factor -> ID .)
    GT              reduce using rule 52 (factor -> ID .)
    LE              reduce using rule 52 (factor -> ID .)
    GE              reduce using rule 52 (factor -> ID .)
    EQ              reduce using rule 52 (factor -> ID .)
    NEQ             reduce using rule 52 (factor -> ID .)
    SEMICOLON       reduce using rule 52 (factor -> ID .)
    COMMA           reduce using rule 52 (factor -> ID .)
    LPAREN          shift and go to state 26


state 29

    (25) statement -> expr SEMICOLON .

    INT             reduce using rule 25 (statement -> expr SEMICOLON .)
    FLOAT           reduce using rule 25 (statement -> expr SEMICOLON .)
    CHAR            reduce using rule 25 (statement -> expr SEMICOLON .)
    ID              reduce using rule 25 (statement -> expr SEMICOLON .)
    IF              reduce using rule 25 (statement -> expr SEMICOLON .)
    WHILE           reduce using rule 25 (statement -> expr SEMICOLON .)
    RETURN          reduce using rule 25 (statement -> expr SEMICOLON .)
    FOR             reduce using rule 25 (statement -> expr SEMICOLON .)
    LBRACE          reduce using rule 25 (statement -> expr SEMICOLON .)
    NUMBER          reduce using rule 25 (statement -> expr SEMICOLON .)
    LPAREN          reduce using rule 25 (statement -> expr SEMICOLON .)
    $end            reduce using rule 25 (statement -> expr SEMICOLON .)
    RBRACE          reduce using rule 25 (statement -> expr SEMICOLON .)
    ELSE            reduce using rule 25 (statement -> expr SEMICOLON .)


state 30

    (38) expr -> expr PLUS . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 56
    factor                         shift and go to state 19

state 31

    (39) expr -> expr MINUS . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 58
    factor                         shift and go to state 19

state 32

    (40) expr -> expr LT . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 59
    factor                         shift and go to state 19

state 33

    (41) expr -> expr GT . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 60
    factor                         shift and go to state 19

state 34

    (42) expr -> expr LE . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 61
    factor                         shift and go to state 19

state 35

    (43) expr -> expr GE . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 62
    factor                         shift and go to state 19

state 36

    (44) expr -> expr EQ . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 63
    factor                         shift and go to state 19

state 37

    (45) expr -> expr NEQ . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    term                           shift and go to state 64
    factor                         shift and go to state 19

state 38

    (21) statement -> IF LPAREN . expr RPAREN statement
    (22) statement -> IF LPAREN . expr RPAREN statement ELSE statement
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 65
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 39

    (23) statement -> WHILE LPAREN . expr RPAREN statement
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 66
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 40

    (24) statement -> RETURN expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 67
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 41

    (26) statement -> FOR LPAREN . for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (27) for_init -> . type ID ASSIGN expr
    (28) for_init -> . ID ASSIGN expr
    (29) for_init -> . empty
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (55) empty -> .

    ID              shift and go to state 70
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    SEMICOLON       reduce using rule 55 (empty -> .)

    for_init                       shift and go to state 68
    type                           shift and go to state 69
    empty                          shift and go to state 71

state 42

    (13) block -> LBRACE statements . RBRACE
    (14) statements -> statements . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    RBRACE          shift and go to state 72
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    statement                      shift and go to state 73
    type                           shift and go to state 45
    expr                           shift and go to state 12
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 43

    (15) statements -> statement .

    RBRACE          reduce using rule 15 (statements -> statement .)
    ID              reduce using rule 15 (statements -> statement .)
    IF              reduce using rule 15 (statements -> statement .)
    WHILE           reduce using rule 15 (statements -> statement .)
    RETURN          reduce using rule 15 (statements -> statement .)
    FOR             reduce using rule 15 (statements -> statement .)
    INT             reduce using rule 15 (statements -> statement .)
    FLOAT           reduce using rule 15 (statements -> statement .)
    CHAR            reduce using rule 15 (statements -> statement .)
    LBRACE          reduce using rule 15 (statements -> statement .)
    NUMBER          reduce using rule 15 (statements -> statement .)
    LPAREN          reduce using rule 15 (statements -> statement .)


state 44

    (16) statements -> empty .

    RBRACE          reduce using rule 16 (statements -> empty .)
    ID              reduce using rule 16 (statements -> empty .)
    IF              reduce using rule 16 (statements -> empty .)
    WHILE           reduce using rule 16 (statements -> empty .)
    RETURN          reduce using rule 16 (statements -> empty .)
    FOR             reduce using rule 16 (statements -> empty .)
    INT             reduce using rule 16 (statements -> empty .)
    FLOAT           reduce using rule 16 (statements -> empty .)
    CHAR            reduce using rule 16 (statements -> empty .)
    LBRACE          reduce using rule 16 (statements -> empty .)
    NUMBER          reduce using rule 16 (statements -> empty .)
    LPAREN          reduce using rule 16 (statements -> empty .)


state 45

    (17) statement -> type . ID ASSIGN expr SEMICOLON
    (18) statement -> type . ID SEMICOLON

    ID              shift and go to state 74


state 46

    (48) term -> term MULTIPLY . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    factor                         shift and go to state 75

state 47

    (49) term -> term DIVIDE . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    ID              shift and go to state 57
    LPAREN          shift and go to state 6

    factor                         shift and go to state 76

state 48

    (4) external_declaration -> type ID LPAREN . params RPAREN block
    (5) external_declaration -> type ID LPAREN . RPAREN block
    (7) params -> . params COMMA param
    (8) params -> . param
    (9) params -> .
    (10) param -> . type ID
    (11) param -> . type ID LBRACKET RBRACKET
    (12) param -> . type ID LBRACKET NUMBER RBRACKET
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 79
    COMMA           reduce using rule 9 (params -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11

  ! RPAREN          [ reduce using rule 9 (params -> .) ]

    type                           shift and go to state 77
    params                         shift and go to state 78
    param                          shift and go to state 80

state 49

    (17) statement -> type ID ASSIGN . expr SEMICOLON
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 81
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 50

    (18) statement -> type ID SEMICOLON .

    INT             reduce using rule 18 (statement -> type ID SEMICOLON .)
    FLOAT           reduce using rule 18 (statement -> type ID SEMICOLON .)
    CHAR            reduce using rule 18 (statement -> type ID SEMICOLON .)
    ID              reduce using rule 18 (statement -> type ID SEMICOLON .)
    IF              reduce using rule 18 (statement -> type ID SEMICOLON .)
    WHILE           reduce using rule 18 (statement -> type ID SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> type ID SEMICOLON .)
    FOR             reduce using rule 18 (statement -> type ID SEMICOLON .)
    LBRACE          reduce using rule 18 (statement -> type ID SEMICOLON .)
    NUMBER          reduce using rule 18 (statement -> type ID SEMICOLON .)
    LPAREN          reduce using rule 18 (statement -> type ID SEMICOLON .)
    $end            reduce using rule 18 (statement -> type ID SEMICOLON .)
    RBRACE          reduce using rule 18 (statement -> type ID SEMICOLON .)
    ELSE            reduce using rule 18 (statement -> type ID SEMICOLON .)


state 51

    (19) statement -> ID ASSIGN expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 82
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 52

    (54) factor -> ID LPAREN args . RPAREN
    (56) args -> args . COMMA expr

    RPAREN          shift and go to state 83
    COMMA           shift and go to state 84


state 53

    (57) args -> expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          reduce using rule 57 (args -> expr .)
    COMMA           reduce using rule 57 (args -> expr .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 54

    (58) args -> empty .

    RPAREN          reduce using rule 58 (args -> empty .)
    COMMA           reduce using rule 58 (args -> empty .)


state 55

    (53) factor -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 53 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 53 (factor -> LPAREN expr RPAREN .)


state 56

    (38) expr -> expr PLUS term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 38 (expr -> expr PLUS term .)
    PLUS            reduce using rule 38 (expr -> expr PLUS term .)
    MINUS           reduce using rule 38 (expr -> expr PLUS term .)
    LT              reduce using rule 38 (expr -> expr PLUS term .)
    GT              reduce using rule 38 (expr -> expr PLUS term .)
    LE              reduce using rule 38 (expr -> expr PLUS term .)
    GE              reduce using rule 38 (expr -> expr PLUS term .)
    EQ              reduce using rule 38 (expr -> expr PLUS term .)
    NEQ             reduce using rule 38 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 38 (expr -> expr PLUS term .)
    COMMA           reduce using rule 38 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 57

    (52) factor -> ID .
    (54) factor -> ID . LPAREN args RPAREN

    MULTIPLY        reduce using rule 52 (factor -> ID .)
    DIVIDE          reduce using rule 52 (factor -> ID .)
    SEMICOLON       reduce using rule 52 (factor -> ID .)
    PLUS            reduce using rule 52 (factor -> ID .)
    MINUS           reduce using rule 52 (factor -> ID .)
    LT              reduce using rule 52 (factor -> ID .)
    GT              reduce using rule 52 (factor -> ID .)
    LE              reduce using rule 52 (factor -> ID .)
    GE              reduce using rule 52 (factor -> ID .)
    EQ              reduce using rule 52 (factor -> ID .)
    NEQ             reduce using rule 52 (factor -> ID .)
    RPAREN          reduce using rule 52 (factor -> ID .)
    COMMA           reduce using rule 52 (factor -> ID .)
    LPAREN          shift and go to state 26


state 58

    (39) expr -> expr MINUS term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 39 (expr -> expr MINUS term .)
    PLUS            reduce using rule 39 (expr -> expr MINUS term .)
    MINUS           reduce using rule 39 (expr -> expr MINUS term .)
    LT              reduce using rule 39 (expr -> expr MINUS term .)
    GT              reduce using rule 39 (expr -> expr MINUS term .)
    LE              reduce using rule 39 (expr -> expr MINUS term .)
    GE              reduce using rule 39 (expr -> expr MINUS term .)
    EQ              reduce using rule 39 (expr -> expr MINUS term .)
    NEQ             reduce using rule 39 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 39 (expr -> expr MINUS term .)
    COMMA           reduce using rule 39 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 59

    (40) expr -> expr LT term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 40 (expr -> expr LT term .)
    PLUS            reduce using rule 40 (expr -> expr LT term .)
    MINUS           reduce using rule 40 (expr -> expr LT term .)
    LT              reduce using rule 40 (expr -> expr LT term .)
    GT              reduce using rule 40 (expr -> expr LT term .)
    LE              reduce using rule 40 (expr -> expr LT term .)
    GE              reduce using rule 40 (expr -> expr LT term .)
    EQ              reduce using rule 40 (expr -> expr LT term .)
    NEQ             reduce using rule 40 (expr -> expr LT term .)
    RPAREN          reduce using rule 40 (expr -> expr LT term .)
    COMMA           reduce using rule 40 (expr -> expr LT term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 60

    (41) expr -> expr GT term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 41 (expr -> expr GT term .)
    PLUS            reduce using rule 41 (expr -> expr GT term .)
    MINUS           reduce using rule 41 (expr -> expr GT term .)
    LT              reduce using rule 41 (expr -> expr GT term .)
    GT              reduce using rule 41 (expr -> expr GT term .)
    LE              reduce using rule 41 (expr -> expr GT term .)
    GE              reduce using rule 41 (expr -> expr GT term .)
    EQ              reduce using rule 41 (expr -> expr GT term .)
    NEQ             reduce using rule 41 (expr -> expr GT term .)
    RPAREN          reduce using rule 41 (expr -> expr GT term .)
    COMMA           reduce using rule 41 (expr -> expr GT term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 61

    (42) expr -> expr LE term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 42 (expr -> expr LE term .)
    PLUS            reduce using rule 42 (expr -> expr LE term .)
    MINUS           reduce using rule 42 (expr -> expr LE term .)
    LT              reduce using rule 42 (expr -> expr LE term .)
    GT              reduce using rule 42 (expr -> expr LE term .)
    LE              reduce using rule 42 (expr -> expr LE term .)
    GE              reduce using rule 42 (expr -> expr LE term .)
    EQ              reduce using rule 42 (expr -> expr LE term .)
    NEQ             reduce using rule 42 (expr -> expr LE term .)
    RPAREN          reduce using rule 42 (expr -> expr LE term .)
    COMMA           reduce using rule 42 (expr -> expr LE term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 62

    (43) expr -> expr GE term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 43 (expr -> expr GE term .)
    PLUS            reduce using rule 43 (expr -> expr GE term .)
    MINUS           reduce using rule 43 (expr -> expr GE term .)
    LT              reduce using rule 43 (expr -> expr GE term .)
    GT              reduce using rule 43 (expr -> expr GE term .)
    LE              reduce using rule 43 (expr -> expr GE term .)
    GE              reduce using rule 43 (expr -> expr GE term .)
    EQ              reduce using rule 43 (expr -> expr GE term .)
    NEQ             reduce using rule 43 (expr -> expr GE term .)
    RPAREN          reduce using rule 43 (expr -> expr GE term .)
    COMMA           reduce using rule 43 (expr -> expr GE term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 63

    (44) expr -> expr EQ term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 44 (expr -> expr EQ term .)
    PLUS            reduce using rule 44 (expr -> expr EQ term .)
    MINUS           reduce using rule 44 (expr -> expr EQ term .)
    LT              reduce using rule 44 (expr -> expr EQ term .)
    GT              reduce using rule 44 (expr -> expr EQ term .)
    LE              reduce using rule 44 (expr -> expr EQ term .)
    GE              reduce using rule 44 (expr -> expr EQ term .)
    EQ              reduce using rule 44 (expr -> expr EQ term .)
    NEQ             reduce using rule 44 (expr -> expr EQ term .)
    RPAREN          reduce using rule 44 (expr -> expr EQ term .)
    COMMA           reduce using rule 44 (expr -> expr EQ term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 64

    (45) expr -> expr NEQ term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 45 (expr -> expr NEQ term .)
    PLUS            reduce using rule 45 (expr -> expr NEQ term .)
    MINUS           reduce using rule 45 (expr -> expr NEQ term .)
    LT              reduce using rule 45 (expr -> expr NEQ term .)
    GT              reduce using rule 45 (expr -> expr NEQ term .)
    LE              reduce using rule 45 (expr -> expr NEQ term .)
    GE              reduce using rule 45 (expr -> expr NEQ term .)
    EQ              reduce using rule 45 (expr -> expr NEQ term .)
    NEQ             reduce using rule 45 (expr -> expr NEQ term .)
    RPAREN          reduce using rule 45 (expr -> expr NEQ term .)
    COMMA           reduce using rule 45 (expr -> expr NEQ term .)
    MULTIPLY        shift and go to state 46
    DIVIDE          shift and go to state 47


state 65

    (21) statement -> IF LPAREN expr . RPAREN statement
    (22) statement -> IF LPAREN expr . RPAREN statement ELSE statement
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          shift and go to state 85
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 66

    (23) statement -> WHILE LPAREN expr . RPAREN statement
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 67

    (24) statement -> RETURN expr SEMICOLON .

    INT             reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    ID              reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    IF              reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    NUMBER          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    $end            reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 24 (statement -> RETURN expr SEMICOLON .)


state 68

    (26) statement -> FOR LPAREN for_init . SEMICOLON expr SEMICOLON for_update RPAREN statement

    SEMICOLON       shift and go to state 87


state 69

    (27) for_init -> type . ID ASSIGN expr

    ID              shift and go to state 88


state 70

    (28) for_init -> ID . ASSIGN expr

    ASSIGN          shift and go to state 89


state 71

    (29) for_init -> empty .

    SEMICOLON       reduce using rule 29 (for_init -> empty .)


state 72

    (13) block -> LBRACE statements RBRACE .

    INT             reduce using rule 13 (block -> LBRACE statements RBRACE .)
    FLOAT           reduce using rule 13 (block -> LBRACE statements RBRACE .)
    CHAR            reduce using rule 13 (block -> LBRACE statements RBRACE .)
    ID              reduce using rule 13 (block -> LBRACE statements RBRACE .)
    IF              reduce using rule 13 (block -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 13 (block -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 13 (block -> LBRACE statements RBRACE .)
    LBRACE          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    NUMBER          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    LPAREN          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    $end            reduce using rule 13 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 13 (block -> LBRACE statements RBRACE .)


state 73

    (14) statements -> statements statement .

    RBRACE          reduce using rule 14 (statements -> statements statement .)
    ID              reduce using rule 14 (statements -> statements statement .)
    IF              reduce using rule 14 (statements -> statements statement .)
    WHILE           reduce using rule 14 (statements -> statements statement .)
    RETURN          reduce using rule 14 (statements -> statements statement .)
    FOR             reduce using rule 14 (statements -> statements statement .)
    INT             reduce using rule 14 (statements -> statements statement .)
    FLOAT           reduce using rule 14 (statements -> statements statement .)
    CHAR            reduce using rule 14 (statements -> statements statement .)
    LBRACE          reduce using rule 14 (statements -> statements statement .)
    NUMBER          reduce using rule 14 (statements -> statements statement .)
    LPAREN          reduce using rule 14 (statements -> statements statement .)


state 74

    (17) statement -> type ID . ASSIGN expr SEMICOLON
    (18) statement -> type ID . SEMICOLON

    ASSIGN          shift and go to state 49
    SEMICOLON       shift and go to state 50


state 75

    (48) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 48 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 48 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 48 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 48 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 48 (term -> term MULTIPLY factor .)
    LT              reduce using rule 48 (term -> term MULTIPLY factor .)
    GT              reduce using rule 48 (term -> term MULTIPLY factor .)
    LE              reduce using rule 48 (term -> term MULTIPLY factor .)
    GE              reduce using rule 48 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 48 (term -> term MULTIPLY factor .)
    NEQ             reduce using rule 48 (term -> term MULTIPLY factor .)
    RPAREN          reduce using rule 48 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 48 (term -> term MULTIPLY factor .)


state 76

    (49) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 49 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 49 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 49 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 49 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 49 (term -> term DIVIDE factor .)
    LT              reduce using rule 49 (term -> term DIVIDE factor .)
    GT              reduce using rule 49 (term -> term DIVIDE factor .)
    LE              reduce using rule 49 (term -> term DIVIDE factor .)
    GE              reduce using rule 49 (term -> term DIVIDE factor .)
    EQ              reduce using rule 49 (term -> term DIVIDE factor .)
    NEQ             reduce using rule 49 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 49 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 49 (term -> term DIVIDE factor .)


state 77

    (10) param -> type . ID
    (11) param -> type . ID LBRACKET RBRACKET
    (12) param -> type . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 90


state 78

    (4) external_declaration -> type ID LPAREN params . RPAREN block
    (7) params -> params . COMMA param

    RPAREN          shift and go to state 91
    COMMA           shift and go to state 92


state 79

    (5) external_declaration -> type ID LPAREN RPAREN . block
    (13) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 17

    block                          shift and go to state 93

state 80

    (8) params -> param .

    RPAREN          reduce using rule 8 (params -> param .)
    COMMA           reduce using rule 8 (params -> param .)


state 81

    (17) statement -> type ID ASSIGN expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 94
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 82

    (19) statement -> ID ASSIGN expr SEMICOLON .

    INT             reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    NUMBER          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)


state 83

    (54) factor -> ID LPAREN args RPAREN .

    MULTIPLY        reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    LT              reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    GT              reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    LE              reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    GE              reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    EQ              reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    NEQ             reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 54 (factor -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 54 (factor -> ID LPAREN args RPAREN .)


state 84

    (56) args -> args COMMA . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 95
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 85

    (21) statement -> IF LPAREN expr RPAREN . statement
    (22) statement -> IF LPAREN expr RPAREN . statement ELSE statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 96
    type                           shift and go to state 45
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 86

    (23) statement -> WHILE LPAREN expr RPAREN . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 97
    type                           shift and go to state 45
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 87

    (26) statement -> FOR LPAREN for_init SEMICOLON . expr SEMICOLON for_update RPAREN statement
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 98
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 88

    (27) for_init -> type ID . ASSIGN expr

    ASSIGN          shift and go to state 99


state 89

    (28) for_init -> ID ASSIGN . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 100
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 90

    (10) param -> type ID .
    (11) param -> type ID . LBRACKET RBRACKET
    (12) param -> type ID . LBRACKET NUMBER RBRACKET

    RPAREN          reduce using rule 10 (param -> type ID .)
    COMMA           reduce using rule 10 (param -> type ID .)
    LBRACKET        shift and go to state 101


state 91

    (4) external_declaration -> type ID LPAREN params RPAREN . block
    (13) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 17

    block                          shift and go to state 102

state 92

    (7) params -> params COMMA . param
    (10) param -> . type ID
    (11) param -> . type ID LBRACKET RBRACKET
    (12) param -> . type ID LBRACKET NUMBER RBRACKET
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11

    param                          shift and go to state 103
    type                           shift and go to state 77

state 93

    (5) external_declaration -> type ID LPAREN RPAREN block .

    INT             reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    CHAR            reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    ID              reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    IF              reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    WHILE           reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    RETURN          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    FOR             reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    LBRACE          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    NUMBER          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    LPAREN          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    $end            reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)


state 94

    (17) statement -> type ID ASSIGN expr SEMICOLON .

    INT             reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    NUMBER          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)


state 95

    (56) args -> args COMMA expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          reduce using rule 56 (args -> args COMMA expr .)
    COMMA           reduce using rule 56 (args -> args COMMA expr .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 96

    (21) statement -> IF LPAREN expr RPAREN statement .
    (22) statement -> IF LPAREN expr RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    INT             reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    FLOAT           reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    CHAR            reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    ID              reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    IF              reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    RETURN          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    FOR             reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    LBRACE          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    NUMBER          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    LPAREN          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    $end            reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    ELSE            shift and go to state 104

  ! ELSE            [ reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .) ]


state 97

    (23) statement -> WHILE LPAREN expr RPAREN statement .

    INT             reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    FLOAT           reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    CHAR            reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    ID              reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    IF              reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    RETURN          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    FOR             reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    LBRACE          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    NUMBER          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    LPAREN          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    $end            reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    ELSE            reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)


state 98

    (26) statement -> FOR LPAREN for_init SEMICOLON expr . SEMICOLON for_update RPAREN statement
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 105
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 99

    (27) for_init -> type ID ASSIGN . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 106
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 100

    (28) for_init -> ID ASSIGN expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       reduce using rule 28 (for_init -> ID ASSIGN expr .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 101

    (11) param -> type ID LBRACKET . RBRACKET
    (12) param -> type ID LBRACKET . NUMBER RBRACKET

    RBRACKET        shift and go to state 107
    NUMBER          shift and go to state 108


state 102

    (4) external_declaration -> type ID LPAREN params RPAREN block .

    INT             reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    FLOAT           reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    CHAR            reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    ID              reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    IF              reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    WHILE           reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    RETURN          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    FOR             reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    LBRACE          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    NUMBER          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    LPAREN          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    $end            reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)


state 103

    (7) params -> params COMMA param .

    RPAREN          reduce using rule 7 (params -> params COMMA param .)
    COMMA           reduce using rule 7 (params -> params COMMA param .)


state 104

    (22) statement -> IF LPAREN expr RPAREN statement ELSE . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 109
    type                           shift and go to state 45
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 105

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON . for_update RPAREN statement
    (30) for_update -> . ID INCREMENT
    (31) for_update -> . ID DECREMENT
    (32) for_update -> . ID ASSIGN expr
    (33) for_update -> . empty
    (55) empty -> .

    ID              shift and go to state 111
    RPAREN          reduce using rule 55 (empty -> .)

    for_update                     shift and go to state 110
    empty                          shift and go to state 112

state 106

    (27) for_init -> type ID ASSIGN expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       reduce using rule 27 (for_init -> type ID ASSIGN expr .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37


state 107

    (11) param -> type ID LBRACKET RBRACKET .

    RPAREN          reduce using rule 11 (param -> type ID LBRACKET RBRACKET .)
    COMMA           reduce using rule 11 (param -> type ID LBRACKET RBRACKET .)


state 108

    (12) param -> type ID LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 113


state 109

    (22) statement -> IF LPAREN expr RPAREN statement ELSE statement .

    INT             reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    CHAR            reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ID              reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    IF              reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    WHILE           reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RETURN          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    FOR             reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    NUMBER          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    $end            reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ELSE            reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)


state 110

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update . RPAREN statement

    RPAREN          shift and go to state 114


state 111

    (30) for_update -> ID . INCREMENT
    (31) for_update -> ID . DECREMENT
    (32) for_update -> ID . ASSIGN expr

    INCREMENT       shift and go to state 115
    DECREMENT       shift and go to state 116
    ASSIGN          shift and go to state 117


state 112

    (33) for_update -> empty .

    RPAREN          reduce using rule 33 (for_update -> empty .)


state 113

    (12) param -> type ID LBRACKET NUMBER RBRACKET .

    RPAREN          reduce using rule 12 (param -> type ID LBRACKET NUMBER RBRACKET .)
    COMMA           reduce using rule 12 (param -> type ID LBRACKET NUMBER RBRACKET .)


state 114

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 118
    type                           shift and go to state 45
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 115

    (30) for_update -> ID INCREMENT .

    RPAREN          reduce using rule 30 (for_update -> ID INCREMENT .)


state 116

    (31) for_update -> ID DECREMENT .

    RPAREN          reduce using rule 31 (for_update -> ID DECREMENT .)


state 117

    (32) for_update -> ID ASSIGN . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . ID
    (53) factor -> . LPAREN expr RPAREN
    (54) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 28
    NUMBER          shift and go to state 20
    LPAREN          shift and go to state 6

    expr                           shift and go to state 119
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 118

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .

    INT             reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    FLOAT           reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    CHAR            reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    ID              reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    IF              reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    WHILE           reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    RETURN          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    FOR             reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    LBRACE          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    NUMBER          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    LPAREN          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    $end            reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    RBRACE          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    ELSE            reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)


state 119

    (32) for_update -> ID ASSIGN expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          reduce using rule 32 (for_update -> ID ASSIGN expr .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    EQ              shift and go to state 36
    NEQ             shift and go to state 37

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 17 resolved as shift
WARNING: shift/reduce conflict for IF in state 17 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 17 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 17 resolved as shift
WARNING: shift/reduce conflict for FOR in state 17 resolved as shift
WARNING: shift/reduce conflict for INT in state 17 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 17 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 17 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 17 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 17 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 17 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 48 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 96 resolved as shift
