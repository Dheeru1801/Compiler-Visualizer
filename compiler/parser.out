Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> external_declarations
Rule 2     external_declarations -> external_declarations external_declaration
Rule 3     external_declarations -> external_declaration
Rule 4     external_declaration -> type ID LPAREN params RPAREN block
Rule 5     external_declaration -> type ID LPAREN RPAREN block
Rule 6     external_declaration -> statement
Rule 7     params -> params COMMA param
Rule 8     params -> param
Rule 9     params -> <empty>
Rule 10    param -> type ID
Rule 11    param -> type ID LBRACKET RBRACKET
Rule 12    param -> type ID LBRACKET NUMBER RBRACKET
Rule 13    block -> LBRACE statements RBRACE
Rule 14    statements -> statements statement
Rule 15    statements -> statement
Rule 16    statements -> empty
Rule 17    statement -> type ID ASSIGN expr SEMICOLON
Rule 18    statement -> type ID SEMICOLON
Rule 19    statement -> ID ASSIGN expr SEMICOLON
Rule 20    statement -> block
Rule 21    statement -> IF LPAREN expr RPAREN statement
Rule 22    statement -> IF LPAREN expr RPAREN statement ELSE statement
Rule 23    statement -> WHILE LPAREN expr RPAREN statement
Rule 24    statement -> RETURN expr SEMICOLON
Rule 25    statement -> expr SEMICOLON
Rule 26    statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
Rule 27    for_init -> type ID ASSIGN expr
Rule 28    for_init -> ID ASSIGN expr
Rule 29    for_init -> empty
Rule 30    for_update -> ID INCREMENT
Rule 31    for_update -> ID DECREMENT
Rule 32    for_update -> ID ASSIGN expr
Rule 33    for_update -> empty
Rule 34    type -> INT
Rule 35    type -> FLOAT
Rule 36    type -> CHAR
Rule 37    expr -> term
Rule 38    expr -> expr PLUS term
Rule 39    expr -> expr MINUS term
Rule 40    expr -> expr LT term
Rule 41    expr -> expr GT term
Rule 42    expr -> expr LE term
Rule 43    expr -> expr GE term
Rule 44    expr -> expr EQ term
Rule 45    expr -> expr NEQ term
Rule 46    expr -> ID INCREMENT
Rule 47    expr -> ID DECREMENT
Rule 48    term -> term MULTIPLY factor
Rule 49    term -> term DIVIDE factor
Rule 50    term -> factor
Rule 51    factor -> NUMBER
Rule 52    factor -> STRING
Rule 53    factor -> ID
Rule 54    factor -> LPAREN expr RPAREN
Rule 55    factor -> ID LPAREN args RPAREN
Rule 56    empty -> <empty>
Rule 57    args -> args COMMA expr
Rule 58    args -> expr
Rule 59    args -> empty

Terminals, with rules where they appear

ASSIGN               : 17 19 27 28 32
CHAR                 : 36
COMMA                : 7 57
DECREMENT            : 31 47
DIVIDE               : 49
ELSE                 : 22
EQ                   : 44
FLOAT                : 35
FOR                  : 26
GE                   : 43
GT                   : 41
ID                   : 4 5 10 11 12 17 18 19 27 28 30 31 32 46 47 53 55
IF                   : 21 22
INCREMENT            : 30 46
INT                  : 34
LBRACE               : 13
LBRACKET             : 11 12
LE                   : 42
LPAREN               : 4 5 21 22 23 26 54 55
LT                   : 40
MINUS                : 39
MULTIPLY             : 48
NEQ                  : 45
NUMBER               : 12 51
PLUS                 : 38
RBRACE               : 13
RBRACKET             : 11 12
RETURN               : 24
RPAREN               : 4 5 21 22 23 26 54 55
SEMICOLON            : 17 18 19 24 25 26 26
STRING               : 52
WHILE                : 23
error                : 

Nonterminals, with rules where they appear

args                 : 55 57
block                : 4 5 20
empty                : 16 29 33 59
expr                 : 17 19 21 22 23 24 25 26 27 28 32 38 39 40 41 42 43 44 45 54 57 58
external_declaration : 2 3
external_declarations : 1 2
factor               : 48 49 50
for_init             : 26
for_update           : 26
param                : 7 8
params               : 4 7
program              : 0
statement            : 6 14 15 21 22 22 23 26
statements           : 13 14
term                 : 37 38 39 40 41 42 43 44 45 48 49
type                 : 4 5 10 11 12 17 18 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . external_declarations
    (2) external_declarations -> . external_declarations external_declaration
    (3) external_declarations -> . external_declaration
    (4) external_declaration -> . type ID LPAREN params RPAREN block
    (5) external_declaration -> . type ID LPAREN RPAREN block
    (6) external_declaration -> . statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    program                        shift and go to state 1
    external_declarations          shift and go to state 2
    external_declaration           shift and go to state 3
    type                           shift and go to state 4
    block                          shift and go to state 7
    statement                      shift and go to state 8
    expr                           shift and go to state 12
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 1

    (0) S' -> program .



state 2

    (1) program -> external_declarations .
    (2) external_declarations -> external_declarations . external_declaration
    (4) external_declaration -> . type ID LPAREN params RPAREN block
    (5) external_declaration -> . type ID LPAREN RPAREN block
    (6) external_declaration -> . statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    $end            reduce using rule 1 (program -> external_declarations .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    external_declaration           shift and go to state 22
    type                           shift and go to state 4
    block                          shift and go to state 7
    statement                      shift and go to state 8
    expr                           shift and go to state 12
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 3

    (3) external_declarations -> external_declaration .

    INT             reduce using rule 3 (external_declarations -> external_declaration .)
    FLOAT           reduce using rule 3 (external_declarations -> external_declaration .)
    CHAR            reduce using rule 3 (external_declarations -> external_declaration .)
    ID              reduce using rule 3 (external_declarations -> external_declaration .)
    IF              reduce using rule 3 (external_declarations -> external_declaration .)
    WHILE           reduce using rule 3 (external_declarations -> external_declaration .)
    RETURN          reduce using rule 3 (external_declarations -> external_declaration .)
    FOR             reduce using rule 3 (external_declarations -> external_declaration .)
    LBRACE          reduce using rule 3 (external_declarations -> external_declaration .)
    NUMBER          reduce using rule 3 (external_declarations -> external_declaration .)
    STRING          reduce using rule 3 (external_declarations -> external_declaration .)
    LPAREN          reduce using rule 3 (external_declarations -> external_declaration .)
    $end            reduce using rule 3 (external_declarations -> external_declaration .)


state 4

    (4) external_declaration -> type . ID LPAREN params RPAREN block
    (5) external_declaration -> type . ID LPAREN RPAREN block
    (17) statement -> type . ID ASSIGN expr SEMICOLON
    (18) statement -> type . ID SEMICOLON

    ID              shift and go to state 23


state 5

    (19) statement -> ID . ASSIGN expr SEMICOLON
    (46) expr -> ID . INCREMENT
    (47) expr -> ID . DECREMENT
    (53) factor -> ID .
    (55) factor -> ID . LPAREN args RPAREN

    ASSIGN          shift and go to state 24
    INCREMENT       shift and go to state 25
    DECREMENT       shift and go to state 26
    MULTIPLY        reduce using rule 53 (factor -> ID .)
    DIVIDE          reduce using rule 53 (factor -> ID .)
    SEMICOLON       reduce using rule 53 (factor -> ID .)
    PLUS            reduce using rule 53 (factor -> ID .)
    MINUS           reduce using rule 53 (factor -> ID .)
    LT              reduce using rule 53 (factor -> ID .)
    GT              reduce using rule 53 (factor -> ID .)
    LE              reduce using rule 53 (factor -> ID .)
    GE              reduce using rule 53 (factor -> ID .)
    EQ              reduce using rule 53 (factor -> ID .)
    NEQ             reduce using rule 53 (factor -> ID .)
    LPAREN          shift and go to state 27


state 6

    (54) factor -> LPAREN . expr RPAREN
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 28
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 7

    (20) statement -> block .

    INT             reduce using rule 20 (statement -> block .)
    FLOAT           reduce using rule 20 (statement -> block .)
    CHAR            reduce using rule 20 (statement -> block .)
    ID              reduce using rule 20 (statement -> block .)
    IF              reduce using rule 20 (statement -> block .)
    WHILE           reduce using rule 20 (statement -> block .)
    RETURN          reduce using rule 20 (statement -> block .)
    FOR             reduce using rule 20 (statement -> block .)
    LBRACE          reduce using rule 20 (statement -> block .)
    NUMBER          reduce using rule 20 (statement -> block .)
    STRING          reduce using rule 20 (statement -> block .)
    LPAREN          reduce using rule 20 (statement -> block .)
    $end            reduce using rule 20 (statement -> block .)
    RBRACE          reduce using rule 20 (statement -> block .)
    ELSE            reduce using rule 20 (statement -> block .)


state 8

    (6) external_declaration -> statement .

    INT             reduce using rule 6 (external_declaration -> statement .)
    FLOAT           reduce using rule 6 (external_declaration -> statement .)
    CHAR            reduce using rule 6 (external_declaration -> statement .)
    ID              reduce using rule 6 (external_declaration -> statement .)
    IF              reduce using rule 6 (external_declaration -> statement .)
    WHILE           reduce using rule 6 (external_declaration -> statement .)
    RETURN          reduce using rule 6 (external_declaration -> statement .)
    FOR             reduce using rule 6 (external_declaration -> statement .)
    LBRACE          reduce using rule 6 (external_declaration -> statement .)
    NUMBER          reduce using rule 6 (external_declaration -> statement .)
    STRING          reduce using rule 6 (external_declaration -> statement .)
    LPAREN          reduce using rule 6 (external_declaration -> statement .)
    $end            reduce using rule 6 (external_declaration -> statement .)


state 9

    (34) type -> INT .

    ID              reduce using rule 34 (type -> INT .)


state 10

    (35) type -> FLOAT .

    ID              reduce using rule 35 (type -> FLOAT .)


state 11

    (36) type -> CHAR .

    ID              reduce using rule 36 (type -> CHAR .)


state 12

    (25) statement -> expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 30
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 13

    (21) statement -> IF . LPAREN expr RPAREN statement
    (22) statement -> IF . LPAREN expr RPAREN statement ELSE statement

    LPAREN          shift and go to state 39


state 14

    (23) statement -> WHILE . LPAREN expr RPAREN statement

    LPAREN          shift and go to state 40


state 15

    (24) statement -> RETURN . expr SEMICOLON
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 41
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 16

    (26) statement -> FOR . LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement

    LPAREN          shift and go to state 42


state 17

    (13) block -> LBRACE . statements RBRACE
    (14) statements -> . statements statement
    (15) statements -> . statement
    (16) statements -> . empty
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (56) empty -> .
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    RBRACE          reduce using rule 56 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

  ! ID              [ reduce using rule 56 (empty -> .) ]
  ! IF              [ reduce using rule 56 (empty -> .) ]
  ! WHILE           [ reduce using rule 56 (empty -> .) ]
  ! RETURN          [ reduce using rule 56 (empty -> .) ]
  ! FOR             [ reduce using rule 56 (empty -> .) ]
  ! INT             [ reduce using rule 56 (empty -> .) ]
  ! FLOAT           [ reduce using rule 56 (empty -> .) ]
  ! CHAR            [ reduce using rule 56 (empty -> .) ]
  ! LBRACE          [ reduce using rule 56 (empty -> .) ]
  ! NUMBER          [ reduce using rule 56 (empty -> .) ]
  ! STRING          [ reduce using rule 56 (empty -> .) ]
  ! LPAREN          [ reduce using rule 56 (empty -> .) ]

    statements                     shift and go to state 43
    statement                      shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46
    expr                           shift and go to state 12
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 18

    (37) expr -> term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 37 (expr -> term .)
    PLUS            reduce using rule 37 (expr -> term .)
    MINUS           reduce using rule 37 (expr -> term .)
    LT              reduce using rule 37 (expr -> term .)
    GT              reduce using rule 37 (expr -> term .)
    LE              reduce using rule 37 (expr -> term .)
    GE              reduce using rule 37 (expr -> term .)
    EQ              reduce using rule 37 (expr -> term .)
    NEQ             reduce using rule 37 (expr -> term .)
    RPAREN          reduce using rule 37 (expr -> term .)
    COMMA           reduce using rule 37 (expr -> term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 19

    (50) term -> factor .

    MULTIPLY        reduce using rule 50 (term -> factor .)
    DIVIDE          reduce using rule 50 (term -> factor .)
    SEMICOLON       reduce using rule 50 (term -> factor .)
    PLUS            reduce using rule 50 (term -> factor .)
    MINUS           reduce using rule 50 (term -> factor .)
    LT              reduce using rule 50 (term -> factor .)
    GT              reduce using rule 50 (term -> factor .)
    LE              reduce using rule 50 (term -> factor .)
    GE              reduce using rule 50 (term -> factor .)
    EQ              reduce using rule 50 (term -> factor .)
    NEQ             reduce using rule 50 (term -> factor .)
    RPAREN          reduce using rule 50 (term -> factor .)
    COMMA           reduce using rule 50 (term -> factor .)


state 20

    (51) factor -> NUMBER .

    MULTIPLY        reduce using rule 51 (factor -> NUMBER .)
    DIVIDE          reduce using rule 51 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 51 (factor -> NUMBER .)
    PLUS            reduce using rule 51 (factor -> NUMBER .)
    MINUS           reduce using rule 51 (factor -> NUMBER .)
    LT              reduce using rule 51 (factor -> NUMBER .)
    GT              reduce using rule 51 (factor -> NUMBER .)
    LE              reduce using rule 51 (factor -> NUMBER .)
    GE              reduce using rule 51 (factor -> NUMBER .)
    EQ              reduce using rule 51 (factor -> NUMBER .)
    NEQ             reduce using rule 51 (factor -> NUMBER .)
    RPAREN          reduce using rule 51 (factor -> NUMBER .)
    COMMA           reduce using rule 51 (factor -> NUMBER .)


state 21

    (52) factor -> STRING .

    MULTIPLY        reduce using rule 52 (factor -> STRING .)
    DIVIDE          reduce using rule 52 (factor -> STRING .)
    SEMICOLON       reduce using rule 52 (factor -> STRING .)
    PLUS            reduce using rule 52 (factor -> STRING .)
    MINUS           reduce using rule 52 (factor -> STRING .)
    LT              reduce using rule 52 (factor -> STRING .)
    GT              reduce using rule 52 (factor -> STRING .)
    LE              reduce using rule 52 (factor -> STRING .)
    GE              reduce using rule 52 (factor -> STRING .)
    EQ              reduce using rule 52 (factor -> STRING .)
    NEQ             reduce using rule 52 (factor -> STRING .)
    RPAREN          reduce using rule 52 (factor -> STRING .)
    COMMA           reduce using rule 52 (factor -> STRING .)


state 22

    (2) external_declarations -> external_declarations external_declaration .

    INT             reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    FLOAT           reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    CHAR            reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    ID              reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    IF              reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    WHILE           reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    RETURN          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    FOR             reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    LBRACE          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    NUMBER          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    STRING          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    LPAREN          reduce using rule 2 (external_declarations -> external_declarations external_declaration .)
    $end            reduce using rule 2 (external_declarations -> external_declarations external_declaration .)


state 23

    (4) external_declaration -> type ID . LPAREN params RPAREN block
    (5) external_declaration -> type ID . LPAREN RPAREN block
    (17) statement -> type ID . ASSIGN expr SEMICOLON
    (18) statement -> type ID . SEMICOLON

    LPAREN          shift and go to state 49
    ASSIGN          shift and go to state 50
    SEMICOLON       shift and go to state 51


state 24

    (19) statement -> ID ASSIGN . expr SEMICOLON
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 52
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 25

    (46) expr -> ID INCREMENT .

    SEMICOLON       reduce using rule 46 (expr -> ID INCREMENT .)
    PLUS            reduce using rule 46 (expr -> ID INCREMENT .)
    MINUS           reduce using rule 46 (expr -> ID INCREMENT .)
    LT              reduce using rule 46 (expr -> ID INCREMENT .)
    GT              reduce using rule 46 (expr -> ID INCREMENT .)
    LE              reduce using rule 46 (expr -> ID INCREMENT .)
    GE              reduce using rule 46 (expr -> ID INCREMENT .)
    EQ              reduce using rule 46 (expr -> ID INCREMENT .)
    NEQ             reduce using rule 46 (expr -> ID INCREMENT .)
    RPAREN          reduce using rule 46 (expr -> ID INCREMENT .)
    COMMA           reduce using rule 46 (expr -> ID INCREMENT .)


state 26

    (47) expr -> ID DECREMENT .

    SEMICOLON       reduce using rule 47 (expr -> ID DECREMENT .)
    PLUS            reduce using rule 47 (expr -> ID DECREMENT .)
    MINUS           reduce using rule 47 (expr -> ID DECREMENT .)
    LT              reduce using rule 47 (expr -> ID DECREMENT .)
    GT              reduce using rule 47 (expr -> ID DECREMENT .)
    LE              reduce using rule 47 (expr -> ID DECREMENT .)
    GE              reduce using rule 47 (expr -> ID DECREMENT .)
    EQ              reduce using rule 47 (expr -> ID DECREMENT .)
    NEQ             reduce using rule 47 (expr -> ID DECREMENT .)
    RPAREN          reduce using rule 47 (expr -> ID DECREMENT .)
    COMMA           reduce using rule 47 (expr -> ID DECREMENT .)


state 27

    (55) factor -> ID LPAREN . args RPAREN
    (57) args -> . args COMMA expr
    (58) args -> . expr
    (59) args -> . empty
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (56) empty -> .
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    RPAREN          reduce using rule 56 (empty -> .)
    COMMA           reduce using rule 56 (empty -> .)
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    args                           shift and go to state 53
    expr                           shift and go to state 54
    empty                          shift and go to state 55
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 28

    (54) factor -> LPAREN expr . RPAREN
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          shift and go to state 56
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 29

    (46) expr -> ID . INCREMENT
    (47) expr -> ID . DECREMENT
    (53) factor -> ID .
    (55) factor -> ID . LPAREN args RPAREN

    INCREMENT       shift and go to state 25
    DECREMENT       shift and go to state 26
    MULTIPLY        reduce using rule 53 (factor -> ID .)
    DIVIDE          reduce using rule 53 (factor -> ID .)
    RPAREN          reduce using rule 53 (factor -> ID .)
    PLUS            reduce using rule 53 (factor -> ID .)
    MINUS           reduce using rule 53 (factor -> ID .)
    LT              reduce using rule 53 (factor -> ID .)
    GT              reduce using rule 53 (factor -> ID .)
    LE              reduce using rule 53 (factor -> ID .)
    GE              reduce using rule 53 (factor -> ID .)
    EQ              reduce using rule 53 (factor -> ID .)
    NEQ             reduce using rule 53 (factor -> ID .)
    SEMICOLON       reduce using rule 53 (factor -> ID .)
    COMMA           reduce using rule 53 (factor -> ID .)
    LPAREN          shift and go to state 27


state 30

    (25) statement -> expr SEMICOLON .

    INT             reduce using rule 25 (statement -> expr SEMICOLON .)
    FLOAT           reduce using rule 25 (statement -> expr SEMICOLON .)
    CHAR            reduce using rule 25 (statement -> expr SEMICOLON .)
    ID              reduce using rule 25 (statement -> expr SEMICOLON .)
    IF              reduce using rule 25 (statement -> expr SEMICOLON .)
    WHILE           reduce using rule 25 (statement -> expr SEMICOLON .)
    RETURN          reduce using rule 25 (statement -> expr SEMICOLON .)
    FOR             reduce using rule 25 (statement -> expr SEMICOLON .)
    LBRACE          reduce using rule 25 (statement -> expr SEMICOLON .)
    NUMBER          reduce using rule 25 (statement -> expr SEMICOLON .)
    STRING          reduce using rule 25 (statement -> expr SEMICOLON .)
    LPAREN          reduce using rule 25 (statement -> expr SEMICOLON .)
    $end            reduce using rule 25 (statement -> expr SEMICOLON .)
    RBRACE          reduce using rule 25 (statement -> expr SEMICOLON .)
    ELSE            reduce using rule 25 (statement -> expr SEMICOLON .)


state 31

    (38) expr -> expr PLUS . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 57
    factor                         shift and go to state 19

state 32

    (39) expr -> expr MINUS . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 59
    factor                         shift and go to state 19

state 33

    (40) expr -> expr LT . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 60
    factor                         shift and go to state 19

state 34

    (41) expr -> expr GT . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 61
    factor                         shift and go to state 19

state 35

    (42) expr -> expr LE . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 62
    factor                         shift and go to state 19

state 36

    (43) expr -> expr GE . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 63
    factor                         shift and go to state 19

state 37

    (44) expr -> expr EQ . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 64
    factor                         shift and go to state 19

state 38

    (45) expr -> expr NEQ . term
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    term                           shift and go to state 65
    factor                         shift and go to state 19

state 39

    (21) statement -> IF LPAREN . expr RPAREN statement
    (22) statement -> IF LPAREN . expr RPAREN statement ELSE statement
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 66
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 40

    (23) statement -> WHILE LPAREN . expr RPAREN statement
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 67
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 41

    (24) statement -> RETURN expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 68
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 42

    (26) statement -> FOR LPAREN . for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (27) for_init -> . type ID ASSIGN expr
    (28) for_init -> . ID ASSIGN expr
    (29) for_init -> . empty
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (56) empty -> .

    ID              shift and go to state 71
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    SEMICOLON       reduce using rule 56 (empty -> .)

    for_init                       shift and go to state 69
    type                           shift and go to state 70
    empty                          shift and go to state 72

state 43

    (13) block -> LBRACE statements . RBRACE
    (14) statements -> statements . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    RBRACE          shift and go to state 73
    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    statement                      shift and go to state 74
    type                           shift and go to state 46
    expr                           shift and go to state 12
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 44

    (15) statements -> statement .

    RBRACE          reduce using rule 15 (statements -> statement .)
    ID              reduce using rule 15 (statements -> statement .)
    IF              reduce using rule 15 (statements -> statement .)
    WHILE           reduce using rule 15 (statements -> statement .)
    RETURN          reduce using rule 15 (statements -> statement .)
    FOR             reduce using rule 15 (statements -> statement .)
    INT             reduce using rule 15 (statements -> statement .)
    FLOAT           reduce using rule 15 (statements -> statement .)
    CHAR            reduce using rule 15 (statements -> statement .)
    LBRACE          reduce using rule 15 (statements -> statement .)
    NUMBER          reduce using rule 15 (statements -> statement .)
    STRING          reduce using rule 15 (statements -> statement .)
    LPAREN          reduce using rule 15 (statements -> statement .)


state 45

    (16) statements -> empty .

    RBRACE          reduce using rule 16 (statements -> empty .)
    ID              reduce using rule 16 (statements -> empty .)
    IF              reduce using rule 16 (statements -> empty .)
    WHILE           reduce using rule 16 (statements -> empty .)
    RETURN          reduce using rule 16 (statements -> empty .)
    FOR             reduce using rule 16 (statements -> empty .)
    INT             reduce using rule 16 (statements -> empty .)
    FLOAT           reduce using rule 16 (statements -> empty .)
    CHAR            reduce using rule 16 (statements -> empty .)
    LBRACE          reduce using rule 16 (statements -> empty .)
    NUMBER          reduce using rule 16 (statements -> empty .)
    STRING          reduce using rule 16 (statements -> empty .)
    LPAREN          reduce using rule 16 (statements -> empty .)


state 46

    (17) statement -> type . ID ASSIGN expr SEMICOLON
    (18) statement -> type . ID SEMICOLON

    ID              shift and go to state 75


state 47

    (48) term -> term MULTIPLY . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    factor                         shift and go to state 76

state 48

    (49) term -> term DIVIDE . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    ID              shift and go to state 58
    LPAREN          shift and go to state 6

    factor                         shift and go to state 77

state 49

    (4) external_declaration -> type ID LPAREN . params RPAREN block
    (5) external_declaration -> type ID LPAREN . RPAREN block
    (7) params -> . params COMMA param
    (8) params -> . param
    (9) params -> .
    (10) param -> . type ID
    (11) param -> . type ID LBRACKET RBRACKET
    (12) param -> . type ID LBRACKET NUMBER RBRACKET
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 80
    COMMA           reduce using rule 9 (params -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11

  ! RPAREN          [ reduce using rule 9 (params -> .) ]

    type                           shift and go to state 78
    params                         shift and go to state 79
    param                          shift and go to state 81

state 50

    (17) statement -> type ID ASSIGN . expr SEMICOLON
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 82
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 51

    (18) statement -> type ID SEMICOLON .

    INT             reduce using rule 18 (statement -> type ID SEMICOLON .)
    FLOAT           reduce using rule 18 (statement -> type ID SEMICOLON .)
    CHAR            reduce using rule 18 (statement -> type ID SEMICOLON .)
    ID              reduce using rule 18 (statement -> type ID SEMICOLON .)
    IF              reduce using rule 18 (statement -> type ID SEMICOLON .)
    WHILE           reduce using rule 18 (statement -> type ID SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> type ID SEMICOLON .)
    FOR             reduce using rule 18 (statement -> type ID SEMICOLON .)
    LBRACE          reduce using rule 18 (statement -> type ID SEMICOLON .)
    NUMBER          reduce using rule 18 (statement -> type ID SEMICOLON .)
    STRING          reduce using rule 18 (statement -> type ID SEMICOLON .)
    LPAREN          reduce using rule 18 (statement -> type ID SEMICOLON .)
    $end            reduce using rule 18 (statement -> type ID SEMICOLON .)
    RBRACE          reduce using rule 18 (statement -> type ID SEMICOLON .)
    ELSE            reduce using rule 18 (statement -> type ID SEMICOLON .)


state 52

    (19) statement -> ID ASSIGN expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 83
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 53

    (55) factor -> ID LPAREN args . RPAREN
    (57) args -> args . COMMA expr

    RPAREN          shift and go to state 84
    COMMA           shift and go to state 85


state 54

    (58) args -> expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          reduce using rule 58 (args -> expr .)
    COMMA           reduce using rule 58 (args -> expr .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 55

    (59) args -> empty .

    RPAREN          reduce using rule 59 (args -> empty .)
    COMMA           reduce using rule 59 (args -> empty .)


state 56

    (54) factor -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 54 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 54 (factor -> LPAREN expr RPAREN .)


state 57

    (38) expr -> expr PLUS term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 38 (expr -> expr PLUS term .)
    PLUS            reduce using rule 38 (expr -> expr PLUS term .)
    MINUS           reduce using rule 38 (expr -> expr PLUS term .)
    LT              reduce using rule 38 (expr -> expr PLUS term .)
    GT              reduce using rule 38 (expr -> expr PLUS term .)
    LE              reduce using rule 38 (expr -> expr PLUS term .)
    GE              reduce using rule 38 (expr -> expr PLUS term .)
    EQ              reduce using rule 38 (expr -> expr PLUS term .)
    NEQ             reduce using rule 38 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 38 (expr -> expr PLUS term .)
    COMMA           reduce using rule 38 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 58

    (53) factor -> ID .
    (55) factor -> ID . LPAREN args RPAREN

    MULTIPLY        reduce using rule 53 (factor -> ID .)
    DIVIDE          reduce using rule 53 (factor -> ID .)
    SEMICOLON       reduce using rule 53 (factor -> ID .)
    PLUS            reduce using rule 53 (factor -> ID .)
    MINUS           reduce using rule 53 (factor -> ID .)
    LT              reduce using rule 53 (factor -> ID .)
    GT              reduce using rule 53 (factor -> ID .)
    LE              reduce using rule 53 (factor -> ID .)
    GE              reduce using rule 53 (factor -> ID .)
    EQ              reduce using rule 53 (factor -> ID .)
    NEQ             reduce using rule 53 (factor -> ID .)
    RPAREN          reduce using rule 53 (factor -> ID .)
    COMMA           reduce using rule 53 (factor -> ID .)
    LPAREN          shift and go to state 27


state 59

    (39) expr -> expr MINUS term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 39 (expr -> expr MINUS term .)
    PLUS            reduce using rule 39 (expr -> expr MINUS term .)
    MINUS           reduce using rule 39 (expr -> expr MINUS term .)
    LT              reduce using rule 39 (expr -> expr MINUS term .)
    GT              reduce using rule 39 (expr -> expr MINUS term .)
    LE              reduce using rule 39 (expr -> expr MINUS term .)
    GE              reduce using rule 39 (expr -> expr MINUS term .)
    EQ              reduce using rule 39 (expr -> expr MINUS term .)
    NEQ             reduce using rule 39 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 39 (expr -> expr MINUS term .)
    COMMA           reduce using rule 39 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 60

    (40) expr -> expr LT term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 40 (expr -> expr LT term .)
    PLUS            reduce using rule 40 (expr -> expr LT term .)
    MINUS           reduce using rule 40 (expr -> expr LT term .)
    LT              reduce using rule 40 (expr -> expr LT term .)
    GT              reduce using rule 40 (expr -> expr LT term .)
    LE              reduce using rule 40 (expr -> expr LT term .)
    GE              reduce using rule 40 (expr -> expr LT term .)
    EQ              reduce using rule 40 (expr -> expr LT term .)
    NEQ             reduce using rule 40 (expr -> expr LT term .)
    RPAREN          reduce using rule 40 (expr -> expr LT term .)
    COMMA           reduce using rule 40 (expr -> expr LT term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 61

    (41) expr -> expr GT term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 41 (expr -> expr GT term .)
    PLUS            reduce using rule 41 (expr -> expr GT term .)
    MINUS           reduce using rule 41 (expr -> expr GT term .)
    LT              reduce using rule 41 (expr -> expr GT term .)
    GT              reduce using rule 41 (expr -> expr GT term .)
    LE              reduce using rule 41 (expr -> expr GT term .)
    GE              reduce using rule 41 (expr -> expr GT term .)
    EQ              reduce using rule 41 (expr -> expr GT term .)
    NEQ             reduce using rule 41 (expr -> expr GT term .)
    RPAREN          reduce using rule 41 (expr -> expr GT term .)
    COMMA           reduce using rule 41 (expr -> expr GT term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 62

    (42) expr -> expr LE term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 42 (expr -> expr LE term .)
    PLUS            reduce using rule 42 (expr -> expr LE term .)
    MINUS           reduce using rule 42 (expr -> expr LE term .)
    LT              reduce using rule 42 (expr -> expr LE term .)
    GT              reduce using rule 42 (expr -> expr LE term .)
    LE              reduce using rule 42 (expr -> expr LE term .)
    GE              reduce using rule 42 (expr -> expr LE term .)
    EQ              reduce using rule 42 (expr -> expr LE term .)
    NEQ             reduce using rule 42 (expr -> expr LE term .)
    RPAREN          reduce using rule 42 (expr -> expr LE term .)
    COMMA           reduce using rule 42 (expr -> expr LE term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 63

    (43) expr -> expr GE term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 43 (expr -> expr GE term .)
    PLUS            reduce using rule 43 (expr -> expr GE term .)
    MINUS           reduce using rule 43 (expr -> expr GE term .)
    LT              reduce using rule 43 (expr -> expr GE term .)
    GT              reduce using rule 43 (expr -> expr GE term .)
    LE              reduce using rule 43 (expr -> expr GE term .)
    GE              reduce using rule 43 (expr -> expr GE term .)
    EQ              reduce using rule 43 (expr -> expr GE term .)
    NEQ             reduce using rule 43 (expr -> expr GE term .)
    RPAREN          reduce using rule 43 (expr -> expr GE term .)
    COMMA           reduce using rule 43 (expr -> expr GE term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 64

    (44) expr -> expr EQ term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 44 (expr -> expr EQ term .)
    PLUS            reduce using rule 44 (expr -> expr EQ term .)
    MINUS           reduce using rule 44 (expr -> expr EQ term .)
    LT              reduce using rule 44 (expr -> expr EQ term .)
    GT              reduce using rule 44 (expr -> expr EQ term .)
    LE              reduce using rule 44 (expr -> expr EQ term .)
    GE              reduce using rule 44 (expr -> expr EQ term .)
    EQ              reduce using rule 44 (expr -> expr EQ term .)
    NEQ             reduce using rule 44 (expr -> expr EQ term .)
    RPAREN          reduce using rule 44 (expr -> expr EQ term .)
    COMMA           reduce using rule 44 (expr -> expr EQ term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 65

    (45) expr -> expr NEQ term .
    (48) term -> term . MULTIPLY factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 45 (expr -> expr NEQ term .)
    PLUS            reduce using rule 45 (expr -> expr NEQ term .)
    MINUS           reduce using rule 45 (expr -> expr NEQ term .)
    LT              reduce using rule 45 (expr -> expr NEQ term .)
    GT              reduce using rule 45 (expr -> expr NEQ term .)
    LE              reduce using rule 45 (expr -> expr NEQ term .)
    GE              reduce using rule 45 (expr -> expr NEQ term .)
    EQ              reduce using rule 45 (expr -> expr NEQ term .)
    NEQ             reduce using rule 45 (expr -> expr NEQ term .)
    RPAREN          reduce using rule 45 (expr -> expr NEQ term .)
    COMMA           reduce using rule 45 (expr -> expr NEQ term .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 66

    (21) statement -> IF LPAREN expr . RPAREN statement
    (22) statement -> IF LPAREN expr . RPAREN statement ELSE statement
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 67

    (23) statement -> WHILE LPAREN expr . RPAREN statement
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          shift and go to state 87
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 68

    (24) statement -> RETURN expr SEMICOLON .

    INT             reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    ID              reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    IF              reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    NUMBER          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    $end            reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 24 (statement -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 24 (statement -> RETURN expr SEMICOLON .)


state 69

    (26) statement -> FOR LPAREN for_init . SEMICOLON expr SEMICOLON for_update RPAREN statement

    SEMICOLON       shift and go to state 88


state 70

    (27) for_init -> type . ID ASSIGN expr

    ID              shift and go to state 89


state 71

    (28) for_init -> ID . ASSIGN expr

    ASSIGN          shift and go to state 90


state 72

    (29) for_init -> empty .

    SEMICOLON       reduce using rule 29 (for_init -> empty .)


state 73

    (13) block -> LBRACE statements RBRACE .

    INT             reduce using rule 13 (block -> LBRACE statements RBRACE .)
    FLOAT           reduce using rule 13 (block -> LBRACE statements RBRACE .)
    CHAR            reduce using rule 13 (block -> LBRACE statements RBRACE .)
    ID              reduce using rule 13 (block -> LBRACE statements RBRACE .)
    IF              reduce using rule 13 (block -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 13 (block -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 13 (block -> LBRACE statements RBRACE .)
    LBRACE          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    NUMBER          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    STRING          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    LPAREN          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    $end            reduce using rule 13 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 13 (block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 13 (block -> LBRACE statements RBRACE .)


state 74

    (14) statements -> statements statement .

    RBRACE          reduce using rule 14 (statements -> statements statement .)
    ID              reduce using rule 14 (statements -> statements statement .)
    IF              reduce using rule 14 (statements -> statements statement .)
    WHILE           reduce using rule 14 (statements -> statements statement .)
    RETURN          reduce using rule 14 (statements -> statements statement .)
    FOR             reduce using rule 14 (statements -> statements statement .)
    INT             reduce using rule 14 (statements -> statements statement .)
    FLOAT           reduce using rule 14 (statements -> statements statement .)
    CHAR            reduce using rule 14 (statements -> statements statement .)
    LBRACE          reduce using rule 14 (statements -> statements statement .)
    NUMBER          reduce using rule 14 (statements -> statements statement .)
    STRING          reduce using rule 14 (statements -> statements statement .)
    LPAREN          reduce using rule 14 (statements -> statements statement .)


state 75

    (17) statement -> type ID . ASSIGN expr SEMICOLON
    (18) statement -> type ID . SEMICOLON

    ASSIGN          shift and go to state 50
    SEMICOLON       shift and go to state 51


state 76

    (48) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 48 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 48 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 48 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 48 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 48 (term -> term MULTIPLY factor .)
    LT              reduce using rule 48 (term -> term MULTIPLY factor .)
    GT              reduce using rule 48 (term -> term MULTIPLY factor .)
    LE              reduce using rule 48 (term -> term MULTIPLY factor .)
    GE              reduce using rule 48 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 48 (term -> term MULTIPLY factor .)
    NEQ             reduce using rule 48 (term -> term MULTIPLY factor .)
    RPAREN          reduce using rule 48 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 48 (term -> term MULTIPLY factor .)


state 77

    (49) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 49 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 49 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 49 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 49 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 49 (term -> term DIVIDE factor .)
    LT              reduce using rule 49 (term -> term DIVIDE factor .)
    GT              reduce using rule 49 (term -> term DIVIDE factor .)
    LE              reduce using rule 49 (term -> term DIVIDE factor .)
    GE              reduce using rule 49 (term -> term DIVIDE factor .)
    EQ              reduce using rule 49 (term -> term DIVIDE factor .)
    NEQ             reduce using rule 49 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 49 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 49 (term -> term DIVIDE factor .)


state 78

    (10) param -> type . ID
    (11) param -> type . ID LBRACKET RBRACKET
    (12) param -> type . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 91


state 79

    (4) external_declaration -> type ID LPAREN params . RPAREN block
    (7) params -> params . COMMA param

    RPAREN          shift and go to state 92
    COMMA           shift and go to state 93


state 80

    (5) external_declaration -> type ID LPAREN RPAREN . block
    (13) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 17

    block                          shift and go to state 94

state 81

    (8) params -> param .

    RPAREN          reduce using rule 8 (params -> param .)
    COMMA           reduce using rule 8 (params -> param .)


state 82

    (17) statement -> type ID ASSIGN expr . SEMICOLON
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 95
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 83

    (19) statement -> ID ASSIGN expr SEMICOLON .

    INT             reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    NUMBER          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 19 (statement -> ID ASSIGN expr SEMICOLON .)


state 84

    (55) factor -> ID LPAREN args RPAREN .

    MULTIPLY        reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    LT              reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    GT              reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    LE              reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    GE              reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    EQ              reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    NEQ             reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 55 (factor -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 55 (factor -> ID LPAREN args RPAREN .)


state 85

    (57) args -> args COMMA . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 96
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 86

    (21) statement -> IF LPAREN expr RPAREN . statement
    (22) statement -> IF LPAREN expr RPAREN . statement ELSE statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 97
    type                           shift and go to state 46
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 87

    (23) statement -> WHILE LPAREN expr RPAREN . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 98
    type                           shift and go to state 46
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 88

    (26) statement -> FOR LPAREN for_init SEMICOLON . expr SEMICOLON for_update RPAREN statement
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 99
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 89

    (27) for_init -> type ID . ASSIGN expr

    ASSIGN          shift and go to state 100


state 90

    (28) for_init -> ID ASSIGN . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 101
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 91

    (10) param -> type ID .
    (11) param -> type ID . LBRACKET RBRACKET
    (12) param -> type ID . LBRACKET NUMBER RBRACKET

    RPAREN          reduce using rule 10 (param -> type ID .)
    COMMA           reduce using rule 10 (param -> type ID .)
    LBRACKET        shift and go to state 102


state 92

    (4) external_declaration -> type ID LPAREN params RPAREN . block
    (13) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 17

    block                          shift and go to state 103

state 93

    (7) params -> params COMMA . param
    (10) param -> . type ID
    (11) param -> . type ID LBRACKET RBRACKET
    (12) param -> . type ID LBRACKET NUMBER RBRACKET
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11

    param                          shift and go to state 104
    type                           shift and go to state 78

state 94

    (5) external_declaration -> type ID LPAREN RPAREN block .

    INT             reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    CHAR            reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    ID              reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    IF              reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    WHILE           reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    RETURN          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    FOR             reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    LBRACE          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    NUMBER          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    STRING          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    LPAREN          reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)
    $end            reduce using rule 5 (external_declaration -> type ID LPAREN RPAREN block .)


state 95

    (17) statement -> type ID ASSIGN expr SEMICOLON .

    INT             reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    NUMBER          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    LPAREN          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 17 (statement -> type ID ASSIGN expr SEMICOLON .)


state 96

    (57) args -> args COMMA expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          reduce using rule 57 (args -> args COMMA expr .)
    COMMA           reduce using rule 57 (args -> args COMMA expr .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 97

    (21) statement -> IF LPAREN expr RPAREN statement .
    (22) statement -> IF LPAREN expr RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    INT             reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    FLOAT           reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    CHAR            reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    ID              reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    IF              reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    RETURN          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    FOR             reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    LBRACE          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    NUMBER          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    STRING          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    LPAREN          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    $end            reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .)
    ELSE            shift and go to state 105

  ! ELSE            [ reduce using rule 21 (statement -> IF LPAREN expr RPAREN statement .) ]


state 98

    (23) statement -> WHILE LPAREN expr RPAREN statement .

    INT             reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    FLOAT           reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    CHAR            reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    ID              reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    IF              reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    WHILE           reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    RETURN          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    FOR             reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    LBRACE          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    NUMBER          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    STRING          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    LPAREN          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    $end            reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    RBRACE          reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)
    ELSE            reduce using rule 23 (statement -> WHILE LPAREN expr RPAREN statement .)


state 99

    (26) statement -> FOR LPAREN for_init SEMICOLON expr . SEMICOLON for_update RPAREN statement
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       shift and go to state 106
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 100

    (27) for_init -> type ID ASSIGN . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 107
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 101

    (28) for_init -> ID ASSIGN expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       reduce using rule 28 (for_init -> ID ASSIGN expr .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 102

    (11) param -> type ID LBRACKET . RBRACKET
    (12) param -> type ID LBRACKET . NUMBER RBRACKET

    RBRACKET        shift and go to state 108
    NUMBER          shift and go to state 109


state 103

    (4) external_declaration -> type ID LPAREN params RPAREN block .

    INT             reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    FLOAT           reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    CHAR            reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    ID              reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    IF              reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    WHILE           reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    RETURN          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    FOR             reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    LBRACE          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    NUMBER          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    STRING          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    LPAREN          reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)
    $end            reduce using rule 4 (external_declaration -> type ID LPAREN params RPAREN block .)


state 104

    (7) params -> params COMMA param .

    RPAREN          reduce using rule 7 (params -> params COMMA param .)
    COMMA           reduce using rule 7 (params -> params COMMA param .)


state 105

    (22) statement -> IF LPAREN expr RPAREN statement ELSE . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 110
    type                           shift and go to state 46
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 106

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON . for_update RPAREN statement
    (30) for_update -> . ID INCREMENT
    (31) for_update -> . ID DECREMENT
    (32) for_update -> . ID ASSIGN expr
    (33) for_update -> . empty
    (56) empty -> .

    ID              shift and go to state 112
    RPAREN          reduce using rule 56 (empty -> .)

    for_update                     shift and go to state 111
    empty                          shift and go to state 113

state 107

    (27) for_init -> type ID ASSIGN expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    SEMICOLON       reduce using rule 27 (for_init -> type ID ASSIGN expr .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38


state 108

    (11) param -> type ID LBRACKET RBRACKET .

    RPAREN          reduce using rule 11 (param -> type ID LBRACKET RBRACKET .)
    COMMA           reduce using rule 11 (param -> type ID LBRACKET RBRACKET .)


state 109

    (12) param -> type ID LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 114


state 110

    (22) statement -> IF LPAREN expr RPAREN statement ELSE statement .

    INT             reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    CHAR            reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ID              reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    IF              reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    WHILE           reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RETURN          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    FOR             reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    NUMBER          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    STRING          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    $end            reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)
    ELSE            reduce using rule 22 (statement -> IF LPAREN expr RPAREN statement ELSE statement .)


state 111

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update . RPAREN statement

    RPAREN          shift and go to state 115


state 112

    (30) for_update -> ID . INCREMENT
    (31) for_update -> ID . DECREMENT
    (32) for_update -> ID . ASSIGN expr

    INCREMENT       shift and go to state 116
    DECREMENT       shift and go to state 117
    ASSIGN          shift and go to state 118


state 113

    (33) for_update -> empty .

    RPAREN          reduce using rule 33 (for_update -> empty .)


state 114

    (12) param -> type ID LBRACKET NUMBER RBRACKET .

    RPAREN          reduce using rule 12 (param -> type ID LBRACKET NUMBER RBRACKET .)
    COMMA           reduce using rule 12 (param -> type ID LBRACKET NUMBER RBRACKET .)


state 115

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN . statement
    (17) statement -> . type ID ASSIGN expr SEMICOLON
    (18) statement -> . type ID SEMICOLON
    (19) statement -> . ID ASSIGN expr SEMICOLON
    (20) statement -> . block
    (21) statement -> . IF LPAREN expr RPAREN statement
    (22) statement -> . IF LPAREN expr RPAREN statement ELSE statement
    (23) statement -> . WHILE LPAREN expr RPAREN statement
    (24) statement -> . RETURN expr SEMICOLON
    (25) statement -> . expr SEMICOLON
    (26) statement -> . FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . CHAR
    (13) block -> . LBRACE statements RBRACE
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 5
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    RETURN          shift and go to state 15
    FOR             shift and go to state 16
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    CHAR            shift and go to state 11
    LBRACE          shift and go to state 17
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 12
    statement                      shift and go to state 119
    type                           shift and go to state 46
    block                          shift and go to state 7
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 116

    (30) for_update -> ID INCREMENT .

    RPAREN          reduce using rule 30 (for_update -> ID INCREMENT .)


state 117

    (31) for_update -> ID DECREMENT .

    RPAREN          reduce using rule 31 (for_update -> ID DECREMENT .)


state 118

    (32) for_update -> ID ASSIGN . expr
    (37) expr -> . term
    (38) expr -> . expr PLUS term
    (39) expr -> . expr MINUS term
    (40) expr -> . expr LT term
    (41) expr -> . expr GT term
    (42) expr -> . expr LE term
    (43) expr -> . expr GE term
    (44) expr -> . expr EQ term
    (45) expr -> . expr NEQ term
    (46) expr -> . ID INCREMENT
    (47) expr -> . ID DECREMENT
    (48) term -> . term MULTIPLY factor
    (49) term -> . term DIVIDE factor
    (50) term -> . factor
    (51) factor -> . NUMBER
    (52) factor -> . STRING
    (53) factor -> . ID
    (54) factor -> . LPAREN expr RPAREN
    (55) factor -> . ID LPAREN args RPAREN

    ID              shift and go to state 29
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21
    LPAREN          shift and go to state 6

    expr                           shift and go to state 120
    term                           shift and go to state 18
    factor                         shift and go to state 19

state 119

    (26) statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .

    INT             reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    FLOAT           reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    CHAR            reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    ID              reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    IF              reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    WHILE           reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    RETURN          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    FOR             reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    LBRACE          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    NUMBER          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    STRING          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    LPAREN          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    $end            reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    RBRACE          reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)
    ELSE            reduce using rule 26 (statement -> FOR LPAREN for_init SEMICOLON expr SEMICOLON for_update RPAREN statement .)


state 120

    (32) for_update -> ID ASSIGN expr .
    (38) expr -> expr . PLUS term
    (39) expr -> expr . MINUS term
    (40) expr -> expr . LT term
    (41) expr -> expr . GT term
    (42) expr -> expr . LE term
    (43) expr -> expr . GE term
    (44) expr -> expr . EQ term
    (45) expr -> expr . NEQ term

    RPAREN          reduce using rule 32 (for_update -> ID ASSIGN expr .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    EQ              shift and go to state 37
    NEQ             shift and go to state 38

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 17 resolved as shift
WARNING: shift/reduce conflict for IF in state 17 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 17 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 17 resolved as shift
WARNING: shift/reduce conflict for FOR in state 17 resolved as shift
WARNING: shift/reduce conflict for INT in state 17 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 17 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 17 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 17 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 17 resolved as shift
WARNING: shift/reduce conflict for STRING in state 17 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 17 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 49 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 97 resolved as shift
